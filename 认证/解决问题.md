---
up:
  - "[[SpringSecurity 課程描述]]"
---
# 思路分析

## 登录

### ①自定义登录接口  
​				
调用ProviderManager的方法进行认证 如果认证通过生成jwt

​把用户信息存入redis中

### ②自定义UserDetailsService 

​在这个实现类中去查询数据库

## 校验：

### ①定义Jwt认证过滤器

​获取token

​解析token获取其中的userid

​从redis中获取用户信息

​存入SecurityContextHolder

---

# 准备工作

## ① 添加依赖

```xml
<!--redis依赖-->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!--jwt依赖-->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-api</artifactId>
	<version>0.12.7</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-impl</artifactId>
	<version>0.12.7</version>
	<scope>runtime</scope>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-jackson</artifactId>
	<version>0.12.7</version>
	<scope>runtime</scope>
</dependency>
```

## ② 添加Redis相关配置

```java
package com.test.config;  
  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.data.redis.connection.RedisConnectionFactory;  
import org.springframework.data.redis.core.RedisTemplate;  
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;  
import org.springframework.data.redis.serializer.StringRedisSerializer;  
  
@Configuration  
public class RedisConfig {  
  
    @Bean  
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {  
        RedisTemplate<String, Object> template = new RedisTemplate<>();  
        template.setConnectionFactory(connectionFactory);  
  
        // Key / HashKey：字串  
        StringRedisSerializer stringSerializer = new StringRedisSerializer();  
  
        // Value / HashValue：通用 Jackson（內建攜帶型別資訊）  
        GenericJackson2JsonRedisSerializer jacksonSerializer = new GenericJackson2JsonRedisSerializer();  
  
        template.setKeySerializer(stringSerializer);  
        template.setValueSerializer(jacksonSerializer);  
        template.setHashKeySerializer(stringSerializer);  
        template.setHashValueSerializer(jacksonSerializer);  
  
        template.afterPropertiesSet();  
        return template;  
    }  
}
```

## ③ 响应类

```java
package com.test.domain;  
  
import com.fasterxml.jackson.annotation.JsonInclude;  
  
@JsonInclude(JsonInclude.Include.NON_NULL)  
public class ResponseResult<T> {  
    /**  
     * 状态码  
     */  
    private Integer code;  
    /**  
     * 提示信息，如果有错误时，前端可以获取该字段进行提示  
     */  
    private String msg;  
    /**  
     * 查询到的结果数据，  
     */  
    private T data;  
  
    public ResponseResult(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
    }  
  
    public ResponseResult(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
    }  
  
    public Integer getCode() {  
        return code;  
    }  
  
    public void setCode(Integer code) {  
        this.code = code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public void setMsg(String msg) {  
        this.msg = msg;  
    }  
  
    public T getData() {  
        return data;  
    }  
  
    public void setData(T data) {  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg, T data) {  
        this.code = code;  
        this.msg = msg;  
        this.data = data;  
    }  
}
```

## ④ 工具类

```java
package com.test.utils;  
  
  
import io.jsonwebtoken.Claims;  
import io.jsonwebtoken.Jwts;  
import io.jsonwebtoken.io.Decoders;  
import io.jsonwebtoken.security.Keys;  
  
import javax.crypto.SecretKey;  
import java.time.Instant;  
import java.util.Date;  
import java.util.UUID;  
  
/** JWT 工具類 */  
public final class JwtUtil {  
  
    /** 預設有效期（毫秒）— 1 小時 */  
    public static final long JWT_TTL = 60 * 60 * 1000L;  
  
    /**  
     * 建議：把祕鑰放到設定檔或環境變數。  
     * 要求：Base64 編碼後的字串，解碼後長度 ≥ 32 bytes（對應 HS256）。  
     * 下面只是示範值，請自行替換為隨機且足夠長度的字串。  
     */  
    public static final String BASE64_SECRET =  
            "bXktdmVyeS1sb25nLXN1cGVyLXNlY3JldC1rZXktMzItYnl0ZXM="; // demo only  
  
    private JwtUtil() {}  
  
    /** 產生 JTI */  
    public static String getUUID() {  
        return UUID.randomUUID().toString().replace("-", "");  
    }  
  
    /** 建立 Token（subject 可放 userId 或 JSON 字串） */  
    public static String createJWT(String subject) {  
        return createJWT(getUUID(), subject, JWT_TTL);  
    }  
  
    /** 建立 Token（自訂 TTL） */  
    public static String createJWT(String subject, Long ttlMillis) {  
        long ttl = (ttlMillis == null ? JWT_TTL : ttlMillis);  
        return createJWT(getUUID(), subject, ttl);  
    }  
  
    /** 建立 Token（自訂 jti 與 TTL） */  
    public static String createJWT(String id, String subject, Long ttlMillis) {  
        SecretKey key = key();  
        Instant now = Instant.now();  
        Date iat = Date.from(now);  
        Date exp = Date.from(now.plusMillis(ttlMillis == null ? JWT_TTL : ttlMillis));  
  
        return Jwts.builder()  
                .id(id)                        // jti  
                .subject(subject)              // 主題（可為 JSON 字串）  
                .issuer("sg")                  // 簽發者  
                .issuedAt(iat)                 // 簽發時間  
                .expiration(exp)               // 過期時間  
                .signWith(key, Jwts.SIG.HS256) // 0.12+：指定演算法常數  
                .compact();  
    }  
  
    /** 驗證並解析 Claims（拋出各式簽章/過期例外時交由上層處理） */  
    public static Claims parseJWT(String jwt) {  
        SecretKey key = key();  
        return Jwts.parser()  
                .verifyWith(key)   // 0.12+ 驗簽  
                .build()  
                .parseSignedClaims(jwt)  
                .getPayload();  
    }  
  
    /** 產生 HMAC-SHA 金鑰（由 Base64 祕鑰還原） */  
    private static SecretKey key() {  
        // 若你想用純文字祕鑰（非 Base64），可改：Keys.hmacShaKeyFor("your-32+bytes-secret".getBytes(StandardCharsets.UTF_8))  
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(BASE64_SECRET));  
    }  
}
```

```java
package com.test.utils;  
  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.data.redis.core.BoundSetOperations;  
import org.springframework.data.redis.core.HashOperations;  
import org.springframework.data.redis.core.RedisTemplate;  
import org.springframework.data.redis.core.ValueOperations;  
import org.springframework.stereotype.Component;  
  
import java.util.*;  
import java.util.concurrent.TimeUnit;  
  
@SuppressWarnings(value = { "unchecked", "rawtypes" })  
@Component  
public class RedisCache  
{  
    @Autowired  
    public RedisTemplate redisTemplate;  
  
    /**  
     * 缓存基本的对象，Integer、String、实体类等  
     *  
     * @param key 缓存的键值  
     * @param value 缓存的值  
     */  
    public <T> void setCacheObject(final String key, final T value)  
    {  
        redisTemplate.opsForValue().set(key, value);  
    }  
  
    /**  
     * 缓存基本的对象，Integer、String、实体类等  
     *  
     * @param key 缓存的键值  
     * @param value 缓存的值  
     * @param timeout 时间  
     * @param timeUnit 时间颗粒度  
     */  
    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)  
    {  
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);  
    }  
  
    /**  
     * 设置有效时间  
     *  
     * @param key Redis键  
     * @param timeout 超时时间  
     * @return true=设置成功；false=设置失败  
     */  
    public boolean expire(final String key, final long timeout)  
    {  
        return expire(key, timeout, TimeUnit.SECONDS);  
    }  
  
    /**  
     * 设置有效时间  
     *  
     * @param key Redis键  
     * @param timeout 超时时间  
     * @param unit 时间单位  
     * @return true=设置成功；false=设置失败  
     */  
    public boolean expire(final String key, final long timeout, final TimeUnit unit)  
    {  
        return redisTemplate.expire(key, timeout, unit);  
    }  
  
    /**  
     * 获得缓存的基本对象。  
     *  
     * @param key 缓存键值  
     * @return 缓存键值对应的数据  
     */  
    public <T> T getCacheObject(final String key)  
    {  
        ValueOperations<String, T> operation = redisTemplate.opsForValue();  
        return operation.get(key);  
    }  
  
    /**  
     * 删除单个对象  
     *  
     * @param key  
     */  
    public boolean deleteObject(final String key)  
    {  
        return redisTemplate.delete(key);  
    }  
  
    /**  
     * 删除集合对象  
     *  
     * @param collection 多个对象  
     * @return  
     */  
    public long deleteObject(final Collection collection)  
    {  
        return redisTemplate.delete(collection);  
    }  
  
    /**  
     * 缓存List数据  
     *  
     * @param key 缓存的键值  
     * @param dataList 待缓存的List数据  
     * @return 缓存的对象  
     */  
    public <T> long setCacheList(final String key, final List<T> dataList)  
    {  
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);  
        return count == null ? 0 : count;  
    }  
  
    /**  
     * 获得缓存的list对象  
     *  
     * @param key 缓存的键值  
     * @return 缓存键值对应的数据  
     */  
    public <T> List<T> getCacheList(final String key)  
    {  
        return redisTemplate.opsForList().range(key, 0, -1);  
    }  
  
    /**  
     * 缓存Set  
     *     * @param key 缓存键值  
     * @param dataSet 缓存的数据  
     * @return 缓存数据的对象  
     */  
    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)  
    {  
        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);  
        Iterator<T> it = dataSet.iterator();  
        while (it.hasNext())  
        {  
            setOperation.add(it.next());  
        }  
        return setOperation;  
    }  
  
    /**  
     * 获得缓存的set  
     *     * @param key  
     * @return  
     */  
    public <T> Set<T> getCacheSet(final String key)  
    {  
        return redisTemplate.opsForSet().members(key);  
    }  
  
    /**  
     * 缓存Map  
     *     * @param key  
     * @param dataMap  
     */  
    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)  
    {  
        if (dataMap != null) {  
            redisTemplate.opsForHash().putAll(key, dataMap);  
        }  
    }  
  
    /**  
     * 获得缓存的Map  
     *     * @param key  
     * @return  
     */  
    public <T> Map<String, T> getCacheMap(final String key)  
    {  
        return redisTemplate.opsForHash().entries(key);  
    }  
  
    /**  
     * 往Hash中存入数据  
     *  
     * @param key Redis键  
     * @param hKey Hash键  
     * @param value 值  
     */  
    public <T> void setCacheMapValue(final String key, final String hKey, final T value)  
    {  
        redisTemplate.opsForHash().put(key, hKey, value);  
    }  
  
    /**  
     * 获取Hash中的数据  
     *  
     * @param key Redis键  
     * @param hKey Hash键  
     * @return Hash中的对象  
     */  
    public <T> T getCacheMapValue(final String key, final String hKey)  
    {  
        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();  
        return opsForHash.get(key, hKey);  
    }  
  
    /**  
     * 删除Hash中的数据  
     *  
     * @param key  
     * @param hkey  
     */  
    public void delCacheMapValue(final String key, final String hkey)  
    {  
        HashOperations hashOperations = redisTemplate.opsForHash();  
        hashOperations.delete(key, hkey);  
    }  
  
    /**  
     * 获取多个Hash中的数据  
     *  
     * @param key Redis键  
     * @param hKeys Hash键集合  
     * @return Hash对象集合  
     */  
    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)  
    {  
        return redisTemplate.opsForHash().multiGet(key, hKeys);  
    }  
  
    /**  
     * 获得缓存的基本对象列表  
     *  
     * @param pattern 字符串前缀  
     * @return 对象列表  
     */  
    public Collection<String> keys(final String pattern)  
    {  
        return redisTemplate.keys(pattern);  
    }  
}
```

```java
package com.test.utils;  
  
  
import jakarta.servlet.http.HttpServletResponse;  
  
import java.io.IOException;  
  
public class WebUtils  
{  
    /**  
     * 将字符串渲染到客户端  
     *  
     * @param response 渲染对象  
     * @param string 待渲染的字符串  
     * @return null  
     */    public static String renderString(HttpServletResponse response, String string) {  
        try  
        {  
            response.setStatus(200);  
            response.setContentType("application/json");  
            response.setCharacterEncoding("utf-8");  
            response.getWriter().print(string);  
        }  
        catch (IOException e)  
        {  
            e.printStackTrace();  
        }  
        return null;  
    }  
}
```

## ⑤ 实体类

```java
package com.test.domain;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.io.Serializable;  
import java.util.Date;  
  
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
// 用户表(User)实体类  
public class User implements Serializable {  
    private static final long serialVersionUID = -40356785423868312L;  
  
    /**  
     * 主键  
     */  
    private Long id;  
    /**  
     * 用户名  
     */  
    private String userName;  
    /**  
     * 昵称  
     */  
    private String nickName;  
    /**  
     * 密码  
     */  
    private String password;  
    /**  
     * 账号状态（0正常 1停用）  
     */  
    private String status;  
    /**  
     * 邮箱  
     */  
    private String email;  
    /**  
     * 手机号  
     */  
    private String phonenumber;  
    /**  
     * 用户性别（0男，1女，2未知）  
     */  
    private String sex;  
    /**  
     * 头像  
     */  
    private String avatar;  
    /**  
     * 用户类型（0管理员，1普通用户）  
     */  
    private String userType;  
    /**  
     * 创建人的用户id  
     */    private Long createBy;  
    /**  
     * 创建时间  
     */  
    private Date createTime;  
    /**  
     * 更新人  
     */  
    private Long updateBy;  
    /**  
     * 更新时间  
     */  
    private Date updateTime;  
    /**  
     * 删除标志（0代表未删除，1代表已删除）  
     */  
    private Integer delFlag;  
}
```

---

# 实现

## 数据库校验用户

​从之前的分析我们可以知道，我们可以自定义一个 UserDetailsService，让 SpringSecurity 使用我们的 UserDetailsService。我们自己的 UserDetailsService 可以从数据库中查询用户名和密码。

##  准备工作

我们先创建一个用户表， 建表语句如下：

```sql
CREATE TABLE `sys_user` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` VARCHAR(64) NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` VARCHAR(64) NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` VARCHAR(64) NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `status` CHAR(1) DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` VARCHAR(64) DEFAULT NULL COMMENT '邮箱',
  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT '手机号',
  `sex` CHAR(1) DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` VARCHAR(128) DEFAULT NULL COMMENT '头像',
  `user_type` CHAR(1) NOT NULL DEFAULT '1' COMMENT '用户类型（0管理员，1普通用户）',
  `create_by` BIGINT(20) DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` DATETIME DEFAULT NULL COMMENT '创建时间',
  `update_by` BIGINT(20) DEFAULT NULL COMMENT '更新人',
  `update_time` DATETIME DEFAULT NULL COMMENT '更新时间',
  `del_flag` INT(11) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表'
```

​ 引入MybatisPuls和mysql驱动的依赖

```xml
<!--mybatis-plus 启动器-->  
<dependency>  
    <groupId>com.baomidou</groupId>  
    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>  
    <version>3.5.12</version>  
</dependency>  
  
<!--mysql 驱动-->  
<dependency>  
    <groupId>com.mysql</groupId>  
    <artifactId>mysql-connector-j</artifactId>  
    <scope>runtime</scope>  
</dependency>
```

​ 配置数据库信息

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
```

​ 定义Mapper接口

```java
public interface UserMapper extends BaseMapper<User> {
}
```

​ 修改User实体类

```java
类名上加 @TableName(value = "sys_user") ,id字段上加 @TableId
```

​ 配置Mapper扫描

```java
@SpringBootApplication
@MapperScan("com.test.mapper")
public class TestSpringSecurityApplication {

	public static void main(String[] args) {
		ConfigurableApplicationContext run = SpringApplication.run(TestSpringSecurityApplication.class, args);
	}
}
```

​ 添加junit依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-test</artifactId>
	<scope>test</scope>
</dependency>
```

​ 测试MP是否能正常使用

```java
@SpringBootTest
public class MapperTest {

    @Autowired
    private UserMapper userMapper;

    @Test
    public void testUserMapper(){
        List<User> users = userMapper.selectList(null);
        System.out.println(users);
    }
}
```

## 核心代码实现

创建一个类实现 UserDetailsService 接口，重写其中的方法。更加用户名从数据库中查询用户信息

```java
package com.test.service.impl;  
  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.test.domain.LoginUser;  
import com.test.domain.User;  
import com.test.mapper.UserMapper;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.core.userdetails.UserDetails;  
import org.springframework.security.core.userdetails.UserDetailsService;  
import org.springframework.security.core.userdetails.UsernameNotFoundException;  
import org.springframework.stereotype.Service;  
  
import java.util.Objects;  
  
@Service  
public class UserDetailsServiceImpl implements UserDetailsService {  
  
    @Autowired  
    private UserMapper userMapper;  
  
    @Override  
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  
        //根据用户名查询用户信息  
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();  
        wrapper.eq(User::getUserName,username);  
        User user = userMapper.selectOne(wrapper);  
        //如果查询不到数据就通过抛出异常来给出提示  
        if(Objects.isNull(user)){  
            throw new RuntimeException("用户名或密码错误");  
        }  
        //TODO 根据用户查询权限信息 添加到LoginUser中  
  
        //封装成UserDetails对象返回  
        return new LoginUser(user);  
    }  
}
```

因为 UserDetailsService 方法的返回值是 UserDetails 类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。

```java
package com.test.domain;  
  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
import org.springframework.security.core.GrantedAuthority;  
import org.springframework.security.core.userdetails.UserDetails;  
  
import java.util.Collection;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
@JsonIgnoreProperties(ignoreUnknown = true) // 反序列化時忽略未知欄位
public class LoginUser implements UserDetails {  
  
    private User user;  
  
  
    @Override  
    public Collection<? extends GrantedAuthority> getAuthorities() {  
        return null;  
    }  
  
    @Override  
    public String getPassword() {  
        return user.getPassword();  
    }  
  
    @Override  
    public String getUsername() {  
        return user.getUserName();  
    }  
  
    @Override  
    public boolean isAccountNonExpired() {  
        return true;  
    }  
  
    @Override  
    public boolean isAccountNonLocked() {  
        return true;  
    }  
  
    @Override  
    public boolean isCredentialsNonExpired() {  
        return true;  
    }  
  
    @Override  
    public boolean isEnabled() {  
        return true;  
    }  
}
```

注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如

![[认证/附件/image-20211216123945882.png]]

这样登陆的时候就可以用 sg 作为用户名，1234 作为密码来登陆了。

## 密码加密存储

实际项目中我们不会把密码明文存储在数据库中。

默认使用的 PasswordEncoder 要求数据库中的密码格式为：{id}password 。它会根据 id 去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换 PasswordEncoder。

我们一般使用 SpringSecurity 为我们提供的 BCryptPasswordEncoder。

我们只需要使用把 BCryptPasswordEncoder 对象注入 Spring 容器中，SpringSecurity 就会使用该PasswordEncoder 来进行密码校验。

我们可以定义一个 SpringSecurity 的配置类

```java
@Configuration  
public class SecurityConfig {  
  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
}
```

記得要將數據庫的密碼換成編碼後的密碼

```java
package com.test.mapper;  
  
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.boot.test.context.SpringBootTest;  
import org.springframework.security.crypto.password.PasswordEncoder;  
  
@SpringBootTest  
public class PasswordTest {  
    @Autowired  
    private PasswordEncoder passwordEncoder;  
  
    @Test  
    public void testPasswordEncoder() {  
        System.out.println(passwordEncoder.encode("1234"));  
    }  
}
```

## 登陆接口

接下我们需要自定义登陆接口，然后让 SpringSecurity 对这个接口放行，让用户访问这个接口的时候不用登录也能访问。

​在接口中我们通过 AuthenticationManager 的 authenticate 方法来进行用户认证,所以需要在SecurityConfig中 配置把 AuthenticationManager 注入容器。

​认证成功的话要生成一个 jwt，放入响应中返回。并且为了让用户下回请求时能通过 jwt 识别出具体的是哪个用户，我们需要把用户信息存入 redis，可以把用户 id 作为 key。

```java
package com.test.controller;

import com.test.domain.ResponseResult;
import com.test.domain.User;
import com.test.service.LoginServcie;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {

    @Autowired
    private LoginServcie loginServcie;

    @PostMapping("/user/login")
    public ResponseResult login(@RequestBody User user){
        return loginServcie.login(user);
    }
}
```

```java
package com.test.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration cfg) throws Exception {
        return cfg.getAuthenticationManager();
    }

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf(csrf -> csrf.disable())

                // 不通过Session获取SecurityContext
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                .authorizeHttpRequests(auth -> auth
                        // 对于登录接口 允许匿名访问
                        .requestMatchers(
                                "/user/login"
                        ).anonymous()
                        // 除上面外的所有请求全部需要鉴权认证
                        .anyRequest().authenticated()
                );

        return http.build();
    }
}
```

```java
package com.test.service;

import com.test.domain.ResponseResult;
import com.test.domain.User;

public interface LoginServcie {
    ResponseResult login(User user);
}
```

```java
package com.test.service.impl;

import com.test.domain.LoginUser;
import com.test.domain.ResponseResult;
import com.test.domain.User;
import com.test.service.LoginServcie;
import com.test.utils.JwtUtil;
import com.test.utils.RedisCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Objects;

@Service
public class LoginServiceImpl implements LoginServcie {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private RedisCache redisCache;

    @Override
    public ResponseResult login(User user) {
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);
        if(Objects.isNull(authenticate)){
            throw new RuntimeException("用户名或密码错误");
        }
        //使用userid生成token
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();
        String userId = loginUser.getUser().getId().toString();
        String jwt = JwtUtil.createJWT(userId);
        //authenticate存入redis
        redisCache.setCacheObject("login:"+userId,loginUser);
        //把token响应给前端
        HashMap<String,String> map = new HashMap<>();
        map.put("token",jwt);
        return new ResponseResult(200,"登陆成功",map);
    }
}
```

## 认证过滤器

我们需要自定义一个过滤器，这个过滤器会去获取请求头中的 token，对 token 进行解析取出其中的userid。

​使用 userid 去 redis 中获取对应的 LoginUser 对象。

​然后封装 Authentication 对象存入SecurityContextHolder

```java
package com.test.filter;  
  
import com.test.domain.LoginUser;  
import com.test.utils.JwtUtil;  
import com.test.utils.RedisCache;  
import io.jsonwebtoken.Claims;  
import jakarta.servlet.FilterChain;  
import jakarta.servlet.ServletException;  
import jakarta.servlet.http.HttpServletRequest;  
import jakarta.servlet.http.HttpServletResponse;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Component;  
import org.springframework.util.StringUtils;  
import org.springframework.web.filter.OncePerRequestFilter;  
  
import java.io.IOException;  
import java.util.Objects;  
  
@Component  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
  
    @Autowired  
    private RedisCache redisCache;  
  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
        //获取token  
        String token = request.getHeader("token");  
        if (!StringUtils.hasText(token)) {  
            //放行  
            filterChain.doFilter(request, response);  
            return;  
        }  
        //解析token  
        String userid;  
        try {  
            Claims claims = JwtUtil.parseJWT(token);  
            userid = claims.getSubject();  
        } catch (Exception e) {  
            e.printStackTrace();  
            throw new RuntimeException("token非法");  
        }  
        //从redis中获取用户信息  
        String redisKey = "login:" + userid;  
        LoginUser loginUser = redisCache.getCacheObject(redisKey);  
        if(Objects.isNull(loginUser)){  
            throw new RuntimeException("用户未登录");  
        }  
        //存入SecurityContextHolder  
        //TODO 获取权限信息封装到Authentication中  
        UsernamePasswordAuthenticationToken authenticationToken =  
                new UsernamePasswordAuthenticationToken(loginUser,null,null);  
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);  
        //放行  
        filterChain.doFilter(request, response);  
    }  
}
```

```java
package com.test.config;

import com.test.filter.JwtAuthenticationTokenFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration cfg) throws Exception {
        return cfg.getAuthenticationManager();
    }

    @Autowired
    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf(csrf -> csrf.disable())

                // 不通过Session获取SecurityContext
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                .authorizeHttpRequests(auth -> auth
                        // 对于登录接口 允许匿名访问
                        .requestMatchers("/user/login").anonymous()
                        // 除上面外的所有请求全部需要鉴权认证
                        .anyRequest().authenticated()
                );

        //把token校验过滤器添加到过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

## 退出登陆

我们只需要定义一个登陆接口，然后获取 SecurityContextHolder 中的认证信息，删除 redis 中对应的数据即可。

```java
@RestController  
public class LoginController {  
  
    @Autowired  
    private LoginServcie loginServcie;   
  
    @RequestMapping("/user/logout")  
    public ResponseResult logout(){  
        return loginServcie.logout();  
    }  
}
```

```java
public interface LoginServcie {  
    ResponseResult logout();  
}
```

```java
package com.test.service.impl;

import com.test.domain.LoginUser;
import com.test.domain.ResponseResult;
import com.test.domain.User;
import com.test.service.LoginServcie;
import com.test.utils.JwtUtil;
import com.test.utils.RedisCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Objects;

@Service
public class LoginServiceImpl implements LoginServcie {

    @Autowired
    private RedisCache redisCache;

    @Override
    public ResponseResult logout() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        Long userid = loginUser.getUser().getId();
        redisCache.deleteObject("login:"+userid);
        return new ResponseResult(200,"退出成功");
    }
}
```

---
